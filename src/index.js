const META_NAME = 'monetization';

class PaymentPointerProtector {

  constructor(paymentPointer) {
    if (typeof paymentPointer === 'string') {
      this.paymentPointer = paymentPointer;
    } else {
      throw new TypeError(`Expected 'paymentPointer' to be a string but got ${typeof paymentPointer}.`);
    }
    this.autoGenerated = false;

    this.guard = this.guard.bind(this);
    this.release = this.release.bind(this);
    this._startMetaObserver = this._startMetaObserver.bind(this);
    this.__onMetaMutated = this.__onMetaMutated.bind(this)
    this._stopMetaObserver = this._stopMetaObserver.bind(this);
    this._startHeadObserver = this._startHeadObserver.bind(this);
    this.__onHeadMutated = this.__onHeadMutated.bind(this)
    this._stopHeadObserver = this._stopHeadObserver.bind(this);
  }

  guard() {
    this._startMetaObserver();
    this._startHeadObserver();
  }

  release() {
    this._stopMetaObserver();
    this._stopHeadObserver();
  }

  _startMetaObserver() {
    // TOFIX: If there is already a payment pointer in head but the pointer
    // provided here is different, it will result in two payment pointers in
    // the head
    let metaTag = document.querySelector(`meta[name=${META_NAME}]`);
    // Creates a new element if tag does not already exist
    if (!metaTag) {
      metaTag = document.createElement('meta');
      metaTag.name = META_NAME;
      metaTag.content = this.paymentPointer;
      document.head.appendChild(metaTag);
      this.autoGenerated = true;
    }
    this.metaObserver = new MutationObserver(this.__onMetaMutated);
    this.metaObserver.observe(metaTag, { attributes: true });
  }

  _stopMetaObserver() {
    if (typeof this.metaObserver?.disconnect === 'function') {
      this.metaObserver.disconnect();
      if (this.autoGenerated) {
        const metaTag = document.querySelector(`meta[name=${META_NAME}]`);
        if (metaTag) { metaTag.remove(); }
      }
    }
  }

  __onMetaMutated(mutationStack) {
    // This makes the element seem like a read-only tag because attribute values
    // are reverted the moment a new value is commited to it
    for (const mutation of mutationStack) {
      if (mutation.target.name !== META_NAME) {
        mutation.target.name = META_NAME;
      }
      if (mutation.target.content !== this.paymentPointer) {
        mutation.target.content = this.paymentPointer;
      }
    }
  }

  _startHeadObserver() {
    this.headObserver = new MutationObserver(this.__onHeadMutated);
    this.headObserver.observe(document.head, { childList: true });
  }

  _stopHeadObserver() {
    if (typeof this.headObserver?.disconnect === 'function') {
      this.headObserver.disconnect();
    }
  }

  __onHeadMutated(mutationStack) {
    // NOTE: People can still add a meta tag with attributes that do not match
    // 'monetization', then rename it to 'monetization' afterwards since no
    // observer attached to it, there will be 2 payment pointers then
    for (const mutation of mutationStack) {
      for (const removedNode of mutation.removedNodes) {
        // In case own payment pointer is deleted
        if (removedNode.name === META_NAME && removedNode.content === this.paymentPointer) {
          this._stopMetaObserver();
          this._startMetaObserver(); // New tag is created in the process
        }
      }
      for (const addedNode of mutation.addedNodes) {
        // In case someone else's payment pointer is added
        if (addedNode.name === META_NAME && addedNode.content !== this.paymentPointer) {
          document.head.removeChild(addedNode);
        }
      }
    }
  }

}

module.exports = PaymentPointerProtector;
